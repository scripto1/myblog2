[{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"알고리즘(algorithm)이란 무엇인가?"},{"content":"ep2. object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"ep2-object와-array-비교\"\u003eep2. object와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"ep.1 자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"ep1-자료구조와-알고리즘\"\u003eep.1 자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"ep3. 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"ep3-알고리즘algorithm이란-무엇인가\"\u003eep3. 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"알고리즘(algorithm)이란 무엇인가?"},{"content":"ep2. object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"ep2-object와-array-비교\"\u003eep2. object와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"ep.1 자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"ep1-자료구조와-알고리즘\"\u003eep.1 자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"ep3. 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"ep3-알고리즘algorithm이란-무엇인가\"\u003eep3. 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"알고리즘(algorithm)이란 무엇인가?"},{"content":"ep2. object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"ep2-object와-array-비교\"\u003eep2. object와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":" 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003chr\u003e\n\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":":smile: 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"smile-알고리즘algorithm이란-무엇인가\"\u003e:smile: 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":":smile: 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"smile-알고리즘algorithm이란-무엇인가\"\u003e\u003ccode\u003e:smile:\u003c/code\u003e 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":":smile: 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"smile-알고리즘algorithm이란-무엇인가\"\u003e:smile: 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"🔍 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"-알고리즘algorithm이란-무엇인가\"\u003e🔍 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"🔍 알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"-알고리즘algorithm이란-무엇인가\"\u003e🔍 알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"frequence counter 주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자. 알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\nfunction validAnagram(str1, str2) { if (str1.length !== str2.length) { return false; } 먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\nlet counter1 = {} let counter2 = {} 각 단어의 알파벳 수를 확인해서 빈 객체{}에 담는다.\nfor (let val of str1) { counter1[val] = (counter1[val] || 0) + 1; } for (let val of str2) { counter2[val] = (counter2[val] || 0) + 1; } ‘for ~ of’는 배열이나 문자열 등을 순회해서 값에 접근한다. 각 단어의 알파벳 개수를 확인해서 아직 할당되지 않았으면 최초로 1을 할당하고, 해당 알파벳 개수가 존재하면 1을 더한다. counter[val]에 값이 존재하지 않으면 undefined(거짓 값)이기 때문에 counter[val] || 0은 0이 된다.\nfor (let key in counter1) { if (counter1[key] !== counter2[key]) return false; } return true; }\n마지막으로 counter1 객체{}의 키를 순회했을 때 각 키의 개수가 counter2 객체{}의 키의 개수와 동일한지 확인해서, 맞으면 참, 다르면 거짓을 반환한다. 여기서 ‘for ~ in’은 객체{}의 프로퍼티를 순회해서 프로퍼티의 키에 접근한다.\nColt 강사님의 해답은 아래와 같다. 각 단어의 알파벳을 순회하는 부분은 내가 조금 수정해서 ‘for ~ of’ 형식으로 변경했다. 내가 풀이했던 방식과는 달리 알파벳의 개수를 담는 객체{}를 하나로 만들고, 두 번째 단어의 알파벳 개수와 비교하는 for 문을 만들면서 코드가 더 간결해졌다.\nfunction validAnagramColt(first, second) { if (first.length !== second.length) { return false; } const lookup = {} for (let letter of first) { lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1 } for (let letter of second) { if (!lookup[letter]) { return false; } else { lookup[letter] -= 1 } } return true }\n","permalink":"http://localhost:1313/myblog2/posts/ep4/","summary":"\u003ch2 id=\"frequence-counter\"\u003efrequence counter\u003c/h2\u003e\n\u003cp\u003e주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자.\n알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction validAnagram(str1, str2) {\nif (str1.length !== str2.length) {\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\u003c/p\u003e","title":"ep4. frequency counter"},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"🔍 ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"frequence counter 주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자. 알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\nfunction validAnagram(str1, str2) { if (str1.length !== str2.length) { return false; } 먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\nlet counter1 = {} let counter2 = {} 각 단어의 알파벳 수를 확인해서 빈 객체{}에 담는다.\nfor (let val of str1) { counter1[val] = (counter1[val] || 0) + 1; } for (let val of str2) { counter2[val] = (counter2[val] || 0) + 1; } ‘for ~ of’는 배열이나 문자열 등을 순회해서 값에 접근한다. 각 단어의 알파벳 개수를 확인해서 아직 할당되지 않았으면 최초로 1을 할당하고, 해당 알파벳 개수가 존재하면 1을 더한다. counter[val]에 값이 존재하지 않으면 undefined(거짓 값)이기 때문에 counter[val] || 0은 0이 된다.\nfor (let key in counter1) { if (counter1[key] !== counter2[key]) return false; } return true; }\n마지막으로 counter1 객체{}의 키를 순회했을 때 각 키의 개수가 counter2 객체{}의 키의 개수와 동일한지 확인해서, 맞으면 참, 다르면 거짓을 반환한다. 여기서 ‘for ~ in’은 객체{}의 프로퍼티를 순회해서 프로퍼티의 키에 접근한다.\nColt 강사님의 해답은 아래와 같다. 각 단어의 알파벳을 순회하는 부분은 내가 조금 수정해서 ‘for ~ of’ 형식으로 변경했다. 내가 풀이했던 방식과는 달리 알파벳의 개수를 담는 객체{}를 하나로 만들고, 두 번째 단어의 알파벳 개수와 비교하는 for 문을 만들면서 코드가 더 간결해졌다.\nfunction validAnagramColt(first, second) { if (first.length !== second.length) { return false; } const lookup = {} for (let letter of first) { lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1 } for (let letter of second) { if (!lookup[letter]) { return false; } else { lookup[letter] -= 1 } } return true } ","permalink":"http://localhost:1313/myblog2/posts/ep4/","summary":"\u003ch2 id=\"frequence-counter\"\u003efrequence counter\u003c/h2\u003e\n\u003cp\u003e주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자.\n알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction validAnagram(str1, str2) {\nif (str1.length !== str2.length) {\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\u003c/p\u003e","title":"ep4. frequency counter"},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"🔍 ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"frequence counter 주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자. 알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\nfunction validAnagram(str1, str2) { if (str1.length !== str2.length) { return false; } 먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\nlet counter1 = {} let counter2 = {} 각 단어의 알파벳 수를 확인해서 빈 객체{}에 담는다.\nfor (let val of str1) { counter1[val] = (counter1[val] || 0) + 1; } for (let val of str2) { counter2[val] = (counter2[val] || 0) + 1; } ‘for ~ of’는 배열이나 문자열 등을 순회해서 값에 접근한다. 각 단어의 알파벳 개수를 확인해서 아직 할당되지 않았으면 최초로 1을 할당하고, 해당 알파벳 개수가 존재하면 1을 더한다. counter[val]에 값이 존재하지 않으면 undefined(거짓 값)이기 때문에 counter[val] || 0은 0이 된다.\nfor (let key in counter1) { if (counter1[key] !== counter2[key]) return false; } return true; }\n마지막으로 counter1 객체{}의 키를 순회했을 때 각 키의 개수가 counter2 객체{}의 키의 개수와 동일한지 확인해서, 맞으면 참, 다르면 거짓을 반환한다. 여기서 ‘for ~ in’은 객체{}의 프로퍼티를 순회해서 프로퍼티의 키에 접근한다.\nColt 강사님의 해답은 아래와 같다. 각 단어의 알파벳을 순회하는 부분은 내가 조금 수정해서 ‘for ~ of’ 형식으로 변경했다. 내가 풀이했던 방식과는 달리 알파벳의 개수를 담는 객체{}를 하나로 만들고, 두 번째 단어의 알파벳 개수와 비교하는 for 문을 만들면서 코드가 더 간결해졌다.\nfunction validAnagramColt(first, second) { if (first.length !== second.length) { return false; } const lookup = {} for (let letter of first) { // let letter = first[val]; lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1 } for (let letter of second) { // let letter = second[val] if (!lookup[letter]) { return false; } else { lookup[letter] -= 1 } } return true } ","permalink":"http://localhost:1313/myblog2/posts/ep4/","summary":"\u003ch2 id=\"frequence-counter\"\u003efrequence counter\u003c/h2\u003e\n\u003cp\u003e주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자.\n알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction validAnagram(str1, str2) {\nif (str1.length !== str2.length) {\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\u003c/p\u003e","title":"ep4. frequency counter"},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"🔍 ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"frequence counter 주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자. 알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\nfunction validAnagram(str1, str2) { if (str1.length !== str2.length) { return false; } 먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\nlet counter1 = {} let counter2 = {} 각 단어의 알파벳 수를 확인해서 빈 객체{}에 담는다.\nfor (let val of str1) { counter1[val] = (counter1[val] || 0) + 1; } for (let val of str2) { counter2[val] = (counter2[val] || 0) + 1; } ‘for ~ of’는 배열이나 문자열 등을 순회해서 값에 접근한다. 각 단어의 알파벳 개수를 확인해서 아직 할당되지 않았으면 최초로 1을 할당하고, 해당 알파벳 개수가 존재하면 1을 더한다. counter[val]에 값이 존재하지 않으면 undefined(거짓 값)이기 때문에 counter[val] || 0은 0이 된다.\nfor (let key in counter1) { if (counter1[key] !== counter2[key]) return false; } return true; }\n마지막으로 counter1 객체{}의 키를 순회했을 때 각 키의 개수가 counter2 객체{}의 키의 개수와 동일한지 확인해서, 맞으면 참, 다르면 거짓을 반환한다. 여기서 ‘for ~ in’은 객체{}의 프로퍼티를 순회해서 프로퍼티의 키에 접근한다.\nColt 강사님의 해답은 아래와 같다. 각 단어의 알파벳을 순회하는 부분은 내가 조금 수정해서 ‘for ~ of’ 형식으로 변경했다. 내가 풀이했던 방식과는 달리 알파벳의 개수를 담는 객체{}를 하나로 만들고, 두 번째 단어의 알파벳 개수와 비교하는 for 문을 만들면서 코드가 더 간결해졌다.\nfunction validAnagramColt(first, second) { if (first.length !== second.length) { return false; } const lookup = {} for (let letter of first) { // let letter = first[val]; lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1 } for (let letter of second) { // let letter = second[val] if (!lookup[letter]) { return false; } else { lookup[letter] -= 1 } } return true } ","permalink":"http://localhost:1313/myblog2/posts/ep4/","summary":"\u003ch2 id=\"frequence-counter\"\u003efrequence counter\u003c/h2\u003e\n\u003cp\u003e주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자.\n알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction validAnagram(str1, str2) {\nif (str1.length !== str2.length) {\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\u003c/p\u003e","title":"ep4. frequency counter"},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"🔍 ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""},{"content":"frequence counter 주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자. 알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\nfunction validAnagram(str1, str2) { if (str1.length !== str2.length) { return false; } 먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\nlet counter1 = {} let counter2 = {} 각 단어의 알파벳 수를 확인해서 빈 객체{}에 담는다.\nfor (let val of str1) { counter1[val] = (counter1[val] || 0) + 1; } for (let val of str2) { counter2[val] = (counter2[val] || 0) + 1; } ‘for ~ of’는 배열이나 문자열 등을 순회해서 값에 접근한다. 각 단어의 알파벳 개수를 확인해서 아직 할당되지 않았으면 최초로 1을 할당하고, 해당 알파벳 개수가 존재하면 1을 더한다. counter[val]에 값이 존재하지 않으면 undefined(거짓 값)이기 때문에 counter[val] || 0은 0이 된다.\nfor (let key in counter1) { if (counter1[key] !== counter2[key]) return false; } return true; }\n마지막으로 counter1 객체{}의 키를 순회했을 때 각 키의 개수가 counter2 객체{}의 키의 개수와 동일한지 확인해서, 맞으면 참, 다르면 거짓을 반환한다. 여기서 ‘for ~ in’은 객체{}의 프로퍼티를 순회해서 프로퍼티의 키에 접근한다.\nColt 강사님의 해답은 아래와 같다. 각 단어의 알파벳을 순회하는 부분은 내가 조금 수정해서 ‘for ~ of’ 형식으로 변경했다. 내가 풀이했던 방식과는 달리 알파벳의 개수를 담는 객체{}를 하나로 만들고, 두 번째 단어의 알파벳 개수와 비교하는 for 문을 만들면서 코드가 더 간결해졌다.\nfunction validAnagramColt(first, second) { if (first.length !== second.length) { return false; } const lookup = {} for (let letter of first) { // let letter = first[val]; lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1 } for (let letter of second) { // let letter = second[val] if (!lookup[letter]) { return false; } else { lookup[letter] -= 1 } } return true } ","permalink":"http://localhost:1313/myblog2/posts/ep4/","summary":"\u003ch2 id=\"frequence-counter\"\u003efrequence counter\u003c/h2\u003e\n\u003cp\u003e주말에 조금 쉬었더니 매일 공부하기로 했던 굳은 다짐이 느슨해지려고 한다. ㅠ 자, 다시 불태워보자.\n알고리즘 문제를 해결하는 여러 가지 패턴 중에 frequency counter가 있다. 두 개의 배열이나 문자열을 새로운 {키: 값}으로 담고 해당 키나 값의 개수를 찾아 비교하는 방법이다. 예시로 애너그램(anagram: 동일한 단어의 순서를 바꾸어 다른 의미의 단어를 만드는 방법)을 확인하는 문제를 풀어봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction validAnagram(str1, str2) {\nif (str1.length !== str2.length) {\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 두 단어의 길이가 같지 않으면 애너그램 형식에 어긋나기 때문에 거짓이다.\u003c/p\u003e","title":"ep4. frequency counter"},{"content":"알고리즘(algorithm)이란 무엇인가? 알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\n여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\n주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다. 문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다. 해결 방법을 여러 단계로 나누어 설명하거나 적는다. 문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다. 문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다. 문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\n점 표기법 객체를 선언했을 때 식별 가능한 키 이름(알파벳, 숫자, 언더스코어로 이루어진다)이 있다면 점 표기법으로 해당 키의 값에 접근할 수 있다.\n대괄호 표기법 프로퍼티의 키 이름이 동적으로 변하거나 빈 문자열 또는 특수 문자가 들어간 키 이름에 접근할 수 있다. 빈 객체를 변수에 할당하고, 동적으로 변하는 객체의 값에 접근하기 위해서는 대괄호 표기법을 사용해야 한다.\n그림과 같이 대괄호 표기법으로 프로퍼티를 접근하면 동적으로 변하는 [char]에는 각각 다른 키가 할당되지만, 점 표기법으로 프로퍼티에 접근하면 키는 char로 고정된다.\n","permalink":"http://localhost:1313/myblog2/posts/ep3/","summary":"\u003ch2 id=\"알고리즘algorithm이란-무엇인가\"\u003e알고리즘(algorithm)이란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e알고리즘은 특정 일을 처리하기 위한 일련의 과정이다. 컴퓨터 공학 관점에서는 데이터를 처리하기 위한 공정이지만 일반적으로는 내가 본 유튜브 영상과 관련된 영상을 추천해 주거나 내가 주문한 상품과 유사한 상품을 구매하라고 부추기는 소비 전략으로 알려진 듯하다.\u003c/p\u003e\n\u003cp\u003e여기서는 컴퓨터 공학 관점에서 문제를 어떻게 해결할지 공부하려고 한다. (아래 내용은 Colt Steele의 알고리즘 강의를 보면서 요약한 내용이다.)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 문제를 나만의 문장으로 재정의하고 문제가 제공하는 input과 output 등 정보가 충분한지 판단한다.\u003c/li\u003e\n\u003cli\u003e문제를 쉽게 이해할 수 있도록 간단한 input과 output으로 예시를 만들어보고, 가능하다면 더 복잡한 예시나 잘못된 input을 대입해 본다.\u003c/li\u003e\n\u003cli\u003e해결 방법을 여러 단계로 나누어 설명하거나 적는다.\u003c/li\u003e\n\u003cli\u003e문제가 어려우면 문제를 단순화해서 풀어보고, 답이 나온다면 어려운 부분에 대입해 본다.\u003c/li\u003e\n\u003cli\u003e문제를 푼 후에 회고와 리팩토링을 해본다. 다른 방법으로 해답을 찾을 수 있는지, 다른 문제에도 적용할 수 있는지, 속도나 메모리 사용을 최적화할 수 있는지를 검토한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제를 풀다 보니 객체 프로퍼티 값을 가져오는 방법이 두 가지인 걸 알게 되었다. 그래서 객체 프로퍼티 값에 접근할 때 사용하는 점 표기법(dot notation)과 대괄호 표기법(square bracket notation)의 차이를 알아봤다.\u003c/p\u003e","title":"🔍 ep3. 알고리즘(algorithm)이란 무엇인가?"},{"content":"object와 array 비교 이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\n객체(object)\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n). 배열(array)\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n). 처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다. ","permalink":"http://localhost:1313/myblog2/posts/ep2/","summary":"\u003ch2 id=\"object와-array-비교\"\u003eobject와 array 비교\u003c/h2\u003e\n\u003cp\u003e이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e객체(object)\u003c/strong\u003e\u003cbr\u003e\n키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -\u0026gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -\u0026gt; O(n).\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e배열(array)\u003c/strong\u003e\u003cbr\u003e\n자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -\u0026gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -\u0026gt; O(n).\n처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.\u003c/li\u003e\n\u003c/ol\u003e","title":"⚖️ ep.2 object와 array 비교"},{"content":"자료구조와 알고리즘 자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\n물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\nBig O 표기법은 한국어로는 점근 표기법이라고 하고, 오메가 표기법, 세타 표기법, 작은 o 표기법 등이 있으니, 수학에 진심인 분들은 추가로 참고하면 될 것 같다.\n","permalink":"http://localhost:1313/myblog2/posts/ep1/","summary":"\u003ch2 id=\"자료구조와-알고리즘\"\u003e자료구조와 알고리즘\u003c/h2\u003e\n\u003cp\u003e자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.\u003cbr\u003e\n요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.\u003c/p\u003e\n\u003cp\u003e물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.\u003c/p\u003e","title":"💡 ep.1 자료구조와 알고리즘"},{"content":"Kim, Hee Yong Kim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\n김희용 소프트웨어 엔지니어, 그래픽 디자이너, 레터 아티스트.\n독일 함부르크 국립조형예술대학(HAW Hamburg)에서 로만 알파벳 캘리그래피와 타이포그래피를 공부했다. 성균관대학교에서 실험적 타이포그래피를 가르쳤으며, 로만 알파벳 서체의 아름다움을 알리기 위해 캘리그래피 아카데미를 운영하고 있다. 문자 예술 전문 출판사 에디시옹 스크립토(Edition Scripto)를 설립했고, 2017년 캘리그래피 작가들과 함께 한국라틴 문자예술협회(KLLAS)를 설립하고 초대 회장을 역임했다.\nheeyongi@gmail.com\nInstagram: @kim_hee_yong_\nwww.editionscripto.com\n","permalink":"http://localhost:1313/myblog2/about/","summary":"\u003ch3 id=\"kim-hee-yong\"\u003eKim, Hee Yong\u003c/h3\u003e\n\u003cp\u003eKim, Hee Yong is a software engineer, graphic designer and letter artist based in Seoul, South Korea. He studied Roman alphabet calligraphy and typography at the Hamburg University of Applied Sciences in Germany (HAW Hamburg).\u003cbr\u003e\nAs an adjunct professor, he taught experimental typography at Sungkyunkwan University and runs calligraphy workshops to spread the beauty of Roman alphabet letter arts.\u003cbr\u003e\nHe manages a publishing company, ‘Edition Scripto’ which exclusively publishes books on letter arts. In 2017 he founded ‘Korea Latin Letter Arts Society’ with other calligraphy enthusiasts.\u003c/p\u003e","title":""}]