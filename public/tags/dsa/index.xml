<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DSA on Scripto Blog</title>
    <link>http://localhost:1313/myblog2/tags/dsa/</link>
    <description>Recent content in DSA on Scripto Blog</description>
    <generator>Hugo -- 0.138.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Nov 2024 14:40:04 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/myblog2/tags/dsa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>⚖️ ep.2 object와 array 비교</title>
      <link>http://localhost:1313/myblog2/posts/ep2/</link>
      <pubDate>Tue, 12 Nov 2024 14:40:04 +0900</pubDate>
      <guid>http://localhost:1313/myblog2/posts/ep2/</guid>
      <description>&lt;h2 id=&#34;object와-array-비교&#34;&gt;object와 array 비교&lt;/h2&gt;
&lt;p&gt;이번에는 Big O 관점에서 객체(object)와 배열(array)이 어떤 장단점을 가졌는지 살펴보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;객체(object)&lt;/strong&gt;&lt;br&gt;
키(key)와 값(value)으로 짝을 이루는 객체는 특정 순서가 없기 때문에 손쉽게 프로퍼티를 추가하거나 삭제할 수 있는 장점이 있다. 따라서 아래 표와 같이 검색을 제외한 대부분 경우 작업이 간단하다. -&amp;gt; O(1). 객체의 특정 프로퍼티를 검색할 때는 객체 안 프로퍼티를 처음부터 하나씩 확인해야 해서 프로퍼티 수(n)에 비례해서 작업 시간도 늘어난다. -&amp;gt; O(n).&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;배열(array)&lt;/strong&gt;&lt;br&gt;
자료에 순서가 필요할 때는 배열을 사용한다. 배열 안 특정 요소에 접근하기는 수월하지만, 요소를 추가하거나 제거할 때는 상황에 따라 다르다. 배열 마지막에 요소를 추가(push)하거나 제거(pop)하는 자바스크립트 메서드는 한번만 동작하면 된다. -&amp;gt; O(1). 반면에 요소를 배열 앞에 추가(unshift)하거나 제거(shift)하면 나머지 요소의 순서를 재배열해야 해서 요소의 양과 맞물려 작업량이 늘어난다. -&amp;gt; O(n).
처음 React 프로젝트를 하면서 배열로 만든 데이터를 필요한 곳에 가져오지 못해서 고생한 적이 있었다. 데이터 형식을 객체로 바꾸면 순서와 상관없이 프로퍼티를 쉽게 가져올 수 있다는 부트캠프 동기의 조언을 듣고 문제를 해결했던 기억이 떠오른다. 지금 생각해 보면 부끄럽지만 그 당시에는 배열과 객체를 어떻게 사용해야 하는지 전혀 감을 잡지 못했다. 세상 낯설었던 코드가 조금은 친숙해진 걸 보면 그래도 과거의 나보단 나아진 것 같아 살짝 어깨가 올라간다.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>💡 ep.1 자료구조와 알고리즘</title>
      <link>http://localhost:1313/myblog2/posts/ep1/</link>
      <pubDate>Tue, 12 Nov 2024 12:25:11 +0900</pubDate>
      <guid>http://localhost:1313/myblog2/posts/ep1/</guid>
      <description>&lt;h2 id=&#34;자료구조와-알고리즘&#34;&gt;자료구조와 알고리즘&lt;/h2&gt;
&lt;p&gt;자료구조와 알고리즘을 공부하다 보면 가장 처음에 마주하는 개념이 바로 Big O 표기법이다.&lt;br&gt;
요약하자면 내가 만든 코드(알고리즘)가 얼마나 효율적으로 작동하는지 계산하는 방법이다. 같은 문제를 다양한 방법으로 풀었을 때 득과 실을 따져볼 수 있고, 코드를 실행했을 때 걸리는 시간과 소모하는 공간(메모리)을 비교해서 비효율적인 코드를 찾아낼 수 있다. 결국 특정 해법에 가장 알맞은 알고리즘을 찾아내서 프로그램 성능을 개선할 수 있다는 얘기다.&lt;/p&gt;
&lt;p&gt;물론 여기에는 동일한 기계에서 작동한다는 전제가 있고, 속도, 메모리 사용, 코드의 가독성 등 여러 변수가 존재하기 때문에 정답이 한 개라고 주장하기 어렵다. 똑똑한 사람들이 이미 아래 차트와 같이 각 알고리즘에 가장 적합한 풀이 방식을 잘 정리해 놨으니 감사한 마음으로 소비하면 될 것 같다. 차트에서도 볼 수 있듯이 O(1), O(n) 영역에 내 알고리즘 해법이 위치하면 일단 혼날 일은 없지 않을까 한다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
